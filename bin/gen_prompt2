#!/usr/bin/env python

# -----------------------------------------------------------------------------
"""
Generate a sourceable prompt

use:

    `prompt.py`

"""
# -----------------------------------------------------------------------------

__author__      = "John van Zantvoort"
__credits__     = ["John van Zantvoort"]
__version__     = 1
__maintainer__  = "John van Zantvoort"
__email__       = "John@vanZantvoort.org"
__status__      = "Development"

import sys
import os
import pprint
import socket
import ConfigParser
from optparse import OptionParser

# this enables the dumping of variables in readable structures.
pp = pprint.PrettyPrinter(indent=4)

class UserConfig:
    CONFIGFILE = os.path.expanduser( '~/.userconfig.cfg' )
    HOSTNAME = socket.gethostname().split('.').pop(0)
    INI_DEFAULTS =  {
                        'main_color': 'light_cyan',
                        'os_color': 'green',
                        'dir_color': 'yellow',
                        'end_color': 'end'
                    }

    def __init__(self):
        """   """
        config = ConfigParser.ConfigParser(self.INI_DEFAULTS)
        config.read(self.CONFIGFILE)
        if not config.has_section(self.HOSTNAME):
            config.add_section(self.HOSTNAME)

        self.config = config

    def defaults(self):
        return self.config.defaults()

    def write(self):
        # Writing our configuration file to 'example.cfg'
        with open(self.CONFIGFILE, 'wb') as configfile:
            self.config.write(configfile)

    def gethostconfig(self, all = True):
        retv = {}

        if all:
            defaults = self.defaults()
            for k in defaults.keys():
                retv[k] = self.config.get(self.HOSTNAME,k)

        else:
            for k in self.config.options(self.HOSTNAME):
                retv[k] = self.config.get(self.HOSTNAME,k)

        return retv

    def set(self, option, value):
        ddict = self.defaults()
        if not option in ddict:
            print "option %s not in list of valid keys" % option
            raise
        self.config.set(self.HOSTNAME, option, value)
        self.write()

class OSId:

    def __init__(self):
        uname = os.uname()
        self.osname = uname[0]
        self.osclass = uname[0].lower()
        {'redhat': {'osclass': 'redhat', 'filepath': '/tmp/lala'}}
        self.lsb_files = {
            '/etc/centos-release': { 'osname': 'CentOS', 'osclass': 'redhat' },
            '/etc/fedora-release': { 'osname': 'Fedora', 'osclass': 'redhat' },
            '/etc/redhat-release': { 'osname': 'RedHat', 'osclass': 'redhat' },
            '/etc/SuSE-release':   { 'osname': 'SuSE',   'osclass': 'suse' },
            '/etc/mandrake-release': { 'osname': 'Mandrake', 'osclass': 'mandrake' },
            '/etc/debian_version': { 'osname': 'Debian', 'osclass': 'debian' },
            '/etc/wrs-release':    { 'osname': 'WindRiver', 'osclass': 'windriver' },
            '/etc/snow-release':   { 'osname': 'Snow', 'osclass': 'snow' }
        }

        if self.osname in "Linux":
            self.Linux()

        elif self.osname in "Darwin":
            self.Darwin()

        elif self.osname in "SunOS":
            self.SunOS()

    def lsb_id(self, filename, strname, strclass):
        """ """
        if os.path.exists(filename):
            self.osname = strname
            self.osclass = strclass
            return True
        return False

    def Linux(self):
        """ """
        if self.lsb_id('/etc/centos-release',
                    self.lsb_files['/etc/centos-release']['osname'],
                    self.lsb_files['/etc/centos-release']['osclass'] ):
            return

        for lsb_file in self.lsb_files.keys():
            tosn = self.lsb_files[lsb_file]['osname']
            tosc = self.lsb_files[lsb_file]['osclass']
            if self.lsb_id(lsb_file,tosn,tosc):
                return

    def Darwin(self):
        self.osclass = "mac"
        pass

    def SunOS(self):
        self.osclass = "solaris"
        pass

    def get_osclass(self):
        return self.osclass

    def get_osname(self):
        return self.osname

    def __repr__(self):
        return self.osclass

class Prompt:


    def __init__(self, *initial_data ):

        arguments = initial_data[0]

        self.format_tmpl = """PS1="%(main_color)s\u@\h%(end_color)s/%(os_color)s%(osname)s%(end_color)s \T [%(dir_color)s\w%(end_color)s]
# " """
        self.color_name = {
            'end': """\[\033[0m\]""",
            'black': """\[\033[0:30m\]""",
            'gray': """\[\033[1:30m\]""",
            'black': """\[\033[0;30m\]""",
            'dark_gray': """\[\033[1;30m\]""",
            'blue': """\[\033[0;34m\]""",
            'light_blue': """\[\033[1;34m\]""",
            'green': """\[\033[0;32m\]""",
            'light_green': """\[\033[1;32m\]""",
            'cyan': """\[\033[0;36m\]""",
            'light_cyan': """\[\033[1;36m\]""",
            'red': """\[\033[0;31m\]""",
            'light_red': """\[\033[1;31m\]""",
            'purple': """\[\033[0;35m\]""",
            'light_purpl': """\[\033[1;35m\]""",
            'brown': """\[\033[0;33m\]""",
            'yellow': """\[\033[1;33m\]""",
            'light_gray': """\[\033[0;37m\]""",
            'white': """\[\033[1;37m\]""" }

        if 'format' in arguments:
            self.format_tmpl = arguments['format']
            del arguments['format']

        self.vars = {}
        self.colors = {}
        self.colors['main_color'] = self.color_name["light_cyan"]
        self.colors['dir_color'] = self.color_name["yellow"]
        self.colors['os_color'] = self.color_name["green"]
        self.colors['end_color'] = self.color_name['end']

        for i in arguments.keys():
            if i.endswith('_color'):
                cn = arguments[i]
                self.colors[i] = self.color_name[cn]
            else:
                self.vars[i] = arguments[i]

    def __repr__(self):

        data = {}
        for i in self.colors.keys():
            data[i] = self.colors[i]
        for i in self.vars.keys():
            data[i] = self.vars[i]
        return self.format_tmpl % data

def gen_prompt(cleanup = False):

    hostname = socket.gethostname().split('.').pop(0)
    prompt_dir = os.path.expanduser("~/.bash/prompt.d")
    prompt_path = "%s/%s.sh" % ( prompt_dir, hostname )

    # make sure the prompt dir exists
    # --------------------------------------
    if not os.path.exists(prompt_dir):
        os.makedirs(prompt_dir)

    if cleanup and os.path.exists(prompt_path):
        os.unlink(prompt_path)

    # default behavior when no options are
    # given is to yield the source command.
    # --------------------------------------
    if not os.path.exists(prompt_path):
        ucobj = UserConfig()
        osid = OSId()
        osclass = osid.get_osclass()
        osname = osid.get_osname().lower()
        hc = ucobj.gethostconfig(False)
        pdata = {   'osclass': osclass,
                    'osname': osname,
                    'main_color': 'green',
                    'dir_color': 'yellow'   }

        if osclass in "redhat":
            pdata['main_color'] = 'red'
            pdata['dir_color'] = 'yellow'

        if osclass in "mac":
            pdata['main_color'] = 'light_cyan'
            pdata['dir_color'] = 'yellow'

        for k in hc.keys():
            pdata[k] = hc[k]

        prompt = Prompt(pdata)
        fh = open(prompt_path,'w')
        fh.write("%s" % prompt)
        fh.close()

    print "source %s" % prompt_path
    sys.exit(0)

if __name__ == '__main__':

    # Variables
    # --------------------------------------
    description = """manage account configuration parameters"""
    option_name = None
    option_value = None
    option_print = False
    option_reset = False
    # --------------------------------------
    #

    # Handle command line options
    # --------------------------------------
    parser = OptionParser(
                            version="%prog 0.1",
                            usage="usage: %prog [options]",
                            description=description )
    parser.add_option( "-n", dest="NAME", help="option name" )
    parser.add_option( "-v", dest="VALUE", help="option value" )
    parser.add_option( "-p", dest="PRINT", action="store_true",
                        help="print values" )
    parser.add_option( "-r", dest="RESET", action="store_true",
                        help="reset the prompt" )

    (options, args) = parser.parse_args()

    if options.NAME:
        option_name = options.NAME

    if options.VALUE:
        option_value = options.VALUE

    if options.PRINT:
        option_print = options.PRINT

    if options.RESET:
        option_reset = options.RESET

    # if the update parameters haven't been
    # called, generate the prompt file.
    # --------------------------------------
    if not option_name and not option_value and not option_print:
        gen_prompt(option_reset)

    # read/create the userconfig object
    # --------------------------------------
    ucobj = UserConfig()

    # print the local options (if any)
    # --------------------------------------
    if option_print:
        option_keys = []
        hc = {}
        if option_name:
            hc = ucobj.gethostconfig(True)
            option_keys.append(option_name)
        else:
            hc = ucobj.gethostconfig(False)
            option_keys = hc.keys()

        for k in option_keys:
            print "%20s: %s" % ( k, hc[k] )

        sys.exit(0)

    #
    # --------------------------------------
    if option_value:
        ucobj.set(option_name, option_value)

